/*{
  "CATEGORIES": ["Fractal", "Psychedelic", "Volumetric", "Audio Reactive"],
  "DESCRIPTION": "Merged ISF: optimized volumetric fractal + kaleidoscopic procedural animation, palettes, texture influence and audio reactivity.",
  "INPUTS": [
    { "NAME": "Speed", "TYPE": "float", "DEFAULT": 8.0, "MIN": 0.1, "MAX": 50.0 },
    { "NAME": "Zoom", "TYPE": "float", "DEFAULT": 1.5, "MIN": 0.5, "MAX": 3.0 },
    { "NAME": "TransformMode", "TYPE": "float", "DEFAULT": 1.8, "MIN": 0, "MAX": 5 },
    { "NAME": "GeometryType", "TYPE": "float", "DEFAULT": 3, "MIN": 0, "MAX": 6 },
    { "NAME": "ChaosIntensity", "TYPE": "float", "DEFAULT": 0.43, "MIN": 0.0, "MAX": 2.0 },
    { "NAME": "ChaosSpeed", "TYPE": "float", "DEFAULT": 0.66, "MIN": 0.1, "MAX": 4.0 },
    { "NAME": "ColorPaletteMode", "TYPE": "float", "DEFAULT": 19, "MIN": 0, "MAX": 19 },
    { "NAME": "Brightness", "TYPE": "float", "DEFAULT": 0.61, "MIN": 0, "MAX": 10.0 },
    { "NAME": "Contrast", "TYPE": "float", "DEFAULT": 9.2, "MIN": 0.1, "MAX": 10.0 },
    { "NAME": "Glow", "TYPE": "float", "DEFAULT": 1.0, "MIN": 0.0, "MAX": 10.0 },
    { "NAME": "Symmetry", "TYPE": "float", "DEFAULT": 0.4, "MIN": 0.0, "MAX": 4.0 },
    { "NAME": "ChaosMix", "TYPE": "float", "DEFAULT": 0.35, "MIN": 0.0, "MAX": 1.0 },
    { "NAME": "Sharpness", "TYPE": "float", "DEFAULT": 0.50, "MIN": 0.1, "MAX": 5.0 },
    { "NAME": "FalloffCurve", "TYPE": "float", "DEFAULT": 0.31, "MIN": 0.1, "MAX": 3.0 },
    { "NAME": "CameraOrbit", "TYPE": "float", "DEFAULT": 0.0, "MIN": -3.14, "MAX": 3.14 },
    { "NAME": "CameraPitch", "TYPE": "float", "DEFAULT": 0.0, "MIN": -1.57, "MAX": 1.57 },
    { "NAME": "CameraRoll", "TYPE": "float", "DEFAULT": 0.0, "MIN": -3.14, "MAX": 3.14 },
    { "NAME": "FocusNear", "TYPE": "float", "DEFAULT": 0.0, "MIN": -5.0, "MAX": 5.0 },
    { "NAME": "FocusFar", "TYPE": "float", "DEFAULT": 0.6, "MIN": 0.1, "MAX": 10.0 },
    { "NAME": "FOV", "TYPE": "float", "DEFAULT": 1.6, "MIN": 0.2, "MAX": 3.0 },
    { "NAME": "StepCount", "TYPE": "float", "DEFAULT": 6, "MIN": 1, "MAX": 60 },
    { "NAME": "Texture", "TYPE": "image" },
    { "NAME": "TextureWarp", "TYPE": "float", "DEFAULT": 0.5, "MIN": 0.0, "MAX": 2.0 },
    { "NAME": "TextureScale", "TYPE": "float", "DEFAULT": 1.0, "MIN": 0.1, "MAX": 10.0 },

    { "NAME": "param1", "TYPE": "float", "MIN": 0.0, "MAX": 1.0, "DEFAULT": 0.5 },
    { "NAME": "param2", "TYPE": "float", "MIN": 0.0, "MAX": 1.0, "DEFAULT": 0.28 },
    { "NAME": "param3", "TYPE": "float", "MIN": 0.0, "MAX": 1.0, "DEFAULT": 0.5 },
    { "NAME": "param4", "TYPE": "float", "MIN": 0.0, "MAX": 10.0, "DEFAULT": 1.0 },
    { "NAME": "zoom", "TYPE": "float", "MIN": 0.1, "MAX": 10.0, "DEFAULT": 0.1 },
    { "NAME": "morph", "TYPE": "float", "MIN": 0.0, "MAX": 2.0, "DEFAULT": 0.0 },
    { "NAME": "speed", "TYPE": "float", "MIN": 0.0, "MAX": 5.0, "DEFAULT": 1.0 },
    { "NAME": "shake", "TYPE": "float", "MIN": 0.0, "MAX": 1.0, "DEFAULT": 0.2 },
    { "NAME": "shimmer", "TYPE": "float", "MIN": 0.0, "MAX": 1.0, "DEFAULT": 0.3 },
    { "NAME": "colorPulse", "TYPE": "float", "MIN": 0.0, "MAX": 1.0, "DEFAULT": 0.0 },
    { "NAME": "palette", "TYPE": "float", "MIN": 0, "MAX": 6, "DEFAULT": 0 },
    { "NAME": "saturation", "TYPE": "float", "MIN": 0.0, "MAX": 2.0, "DEFAULT": 1.0 },
    { "NAME": "manualTime", "TYPE": "float", "MIN": 0.0, "MAX": 1000.0, "DEFAULT": 0.0 }
  ]
}*/

#ifdef GL_ES
precision mediump float;
#endif

#define MAX_STEPS 48
#define BAILOUT 16.0
#define PI 3.14159265359
#define MAX_ITERS 128



/* inputs (ISF uniforms auto-generated by host from JSON above):
   Speed, Zoom, TransformMode, GeometryType, ChaosIntensity, ChaosSpeed,
   ColorPaletteMode, Brightness, Contrast, Glow, Symmetry, ChaosMix,
   Sharpness, FalloffCurve, CameraOrbit, CameraPitch, CameraRoll, FocusNear,
   FocusFar, FOV, StepCount, TextureWarp, TextureScale,
   param1..param4, zoom (lowercase), morph, speed (alt), shake, shimmer,
   colorPulse, palette, saturation, manualTime
*/

/* -- helpers & camera -- */
mat3 cameraMatrix(float orbit, float pitch, float roll) {
  float co = cos(orbit), so = sin(orbit);
  float cp = cos(pitch), sp = sin(pitch);
  float cr = cos(roll), sr = sin(roll);
  return mat3(
    co * cr + so * sp * sr, sr * cp, -so * cr + co * sp * sr,
    -co * sr + so * sp * cr, cr * cp, sr * so + co * sp * cr,
    so * cp, -sp, co * cp
  );
}

/* palette blending helpers (merged styles) */
vec3 pal(vec3 a, vec3 b, vec3 c, vec3 d, float t) {
  return a + b * cos(6.2831853 * (c * t + d));
}

vec3 getPaletteColor(int mode, float t) {
  // several palette modes combined from both shaders; use mode to pick
  if (mode == 0) return pal(vec3(0.5), vec3(0.5), vec3(1.0), vec3(0.0), t);
  if (mode == 1) return vec3(0.5 + 0.5*sin(6.2831*t + vec3(0.0,2.0,4.0)));
  if (mode == 2) return vec3(0.6 + 0.4*cos(10.0*t + vec3(1.0,2.0,3.0)));
  if (mode == 3) return vec3(sin(5.0*t+1.0), sin(4.0*t+3.0), sin(3.0*t+5.0))*0.5 + 0.5;
  if (mode == 4) return vec3(cos(t*3.0), sin(t*5.0), cos(t*7.0))*0.5 + 0.5;
  if (mode == 5) return pal(vec3(0.5 + 0.4*sin(float(mode)*0.5), 0.6 + 0.3*cos(float(mode)*1.2), 0.4 + 0.5*sin(float(mode)*0.9)),
                           vec3(0.4),
                           vec3(1.0,1.3,0.7),
                           vec3(0.1,0.2,0.3),
                           t);
  // fallback animated palettes
  return vec3(0.5 + 0.5*sin(vec3(t*6.0, t*7.0, t*8.0)));
}

/* triplanar texture sampling */
vec3 triplanarTexture(vec3 p, float scale) {
  vec3 blend = normalize(abs(p) + 1e-6);
  blend = pow(blend, vec3(4.0));
  blend /= dot(blend, vec3(1.0));
  vec2 xz = fract(p.zy * scale);
  vec2 yz = fract(p.xz * scale);
  vec2 xy = fract(p.xy * scale);
  vec3 tx = texture2D(Texture, xz).rgb;
  vec3 ty = texture2D(Texture, yz).rgb;
  vec3 tz = texture2D(Texture, xy).rgb;
  return tx * blend.x + ty * blend.y + tz * blend.z;
}

/* fractal geometry / distance function */
float shapeSpikeFractal(vec3 p, int steps) {
  float d = 0.0;
  for (int i = 0; i < MAX_ITERS; i++) {
    if (i >= steps) break;
    // cheap normalized fold + repel
    float r2 = dot(p,p) + 0.001;
    p = abs(p) / r2 - 0.5;
    p *= 0.95;
    d += length(p);
  }
  return d / 20.0;
}

float shapeChaos(vec3 p, float chaos, float chspd) {
  return (sin(p.x*3.0 + TIME*chspd) + sin(p.y*4.0 + TIME*chspd*1.2) + sin(p.z*5.0 + TIME*chspd*0.8)) * chaos;
}

float sceneSDF(vec3 p, int geo, float chaos, float mixAmt, int steps) {
  float base;
  if (geo == 0) base = length(p) - 1.0;
  else if (geo == 1) {
    vec2 q = vec2(length(p.xz)-1.0, p.y);
    base = length(q) - 0.3;
  } else if (geo == 2) base = shapeSpikeFractal(p * 1.2, steps);
  else base = shapeSpikeFractal(p, steps);
  return mix(base, shapeChaos(p, chaos, ChaosSpeed), mixAmt);
}

/* transforms & procedural motion */
vec3 applyTransform(vec3 p, int mode, float chaos, float sym, float chspd) {
  p *= max(sym, 0.001);
  if (mode == 1) p = abs(p);
  else if (mode == 2) p += sin(p * 3.0 + TIME * chspd) * chaos * 0.3;
  else if (mode == 3) {
    p += sin(p * (1.0 + chaos * 2.0) + TIME * chspd) * chaos * 0.5;
    p = fract(p * 1.5) - 0.75;
  }
  if (mode == 4 || mode == 5) {
    float a = atan(p.z, p.x);
    float r = length(p.xz);
    float spin = TIME * chspd * (mode == 4 ? 0.2 : 0.3);
    a += spin;
    p.x = cos(a) * r;
    p.z = sin(a) * r;
  }
  return p;
}

/* kaleidoscopic UV iterative motion (from second shader) */
void kaleidoIter(inout vec2 uv, inout vec2 vv, float tm, float tm2, float morphFac) {
  float R = 100.0;
  float RR = 10.0;
  float RRR = 10.0;
  float a = (1.0 - (sin(tm) + cos(tm * 0.02) + sin(tm * 0.05) + cos(tm * -0.04) + sin(tm * 10.3) + 1.0) * 0.35) * 0.05;
  float C = cos(tm2 * 0.003 + a * 0.001) * 1.1;
  float S = sin(tm2 * 0.0033 + a * 0.023) * 1.1;
  float C2 = cos(tm2 * 0.024 + a * 0.023) * 3.1;
  float S2 = sin(tm2 * 0.03 + a * 0.01) * 3.3;
  vec2 xa = vec2(C, -S);
  vec2 ya = vec2(S, C);
  vec2 xa2 = vec2(C2, -S2);
  vec2 ya2 = vec2(S2, C2);
  vec2 shift = vec2(0.033, 0.14);
  vec2 shift2 = vec2(-0.023, -0.22);
  float Z = 0.4 + (sin(tm) + cos(tm * 0.02) + 1.0) * 0.35 * 0.3;
  float m = 0.99 + sin(TIME * 0.003) * 0.0003 + morphFac * 0.01;

  for (int i = 80; i < 300; i++) {
    float r = dot(uv, uv);
    float r2 = dot(vv, vv);
    if (r > 1.0) uv *= 1.0 / r;
    if (r2 > 1.0) vv *= 1.0 / r2;
    R *= m; R += r;
    R *= m; R += r2;
    if (i < 299) {
      RR *= m; RR += r;
      RR *= m; RR += r2;
      if (i < 298) {
        RRR *= m; RRR += r;
        RRR *= m; RRR += r2;
      }
    }
    uv = vec2(dot(uv, xa), dot(uv, ya)) * Z + shift;
    vv = vec2(dot(vv, xa2), dot(vv, ya2)) * Z + shift2;
  }
}

/* main */
void main() {
  // normalized coordinates
  vec2 frag = gl_FragCoord.xy;
  vec2 uv0 = (frag - 0.5 * RENDERSIZE.xy) / min(RENDERSIZE.x, RENDERSIZE.y);
  vec2 uv = uv0 * zoom * 90.0;           // second-shader zoom (procedural)
  vec2 vv = uv;

  // time / rhythm from second shader to drive overall animation
  float rotationAngle = mod(TIME * speed * 1000.1, 60.1415 * 20000.0);
  float minT = 100.0;
  float maxT = 130.0;
  float ft = mod(TIME * param2 * speed, maxT - minT) + minT;
  float tm = ft * 0.1 * param2 + manualTime;
  float tm2 = ft * 0.3 * param2;

  // small motion seed (mspt)
  vec2 mspt = (vec2(
    sin(tm) + cos(tm * 0.02) + sin(tm * 0.05) + cos(tm * -0.04) + sin(tm * 10.3),
    cos(tm) + sin(tm * 0.01) + cos(tm * 0.8) + sin(tm * -0.1) + cos(tm * 0.005)
  ) + 1.0) * 0.35;

  // kaleidoscopic iterative deformation applied to uv used for palette & driving transforms
  vec2 rotatedUV = mat2(cos(rotationAngle), -sin(rotationAngle), sin(rotationAngle), cos(rotationAngle)) * uv;
  kaleidoIter(rotatedUV, vv, tm, tm2, morph);

  // produce motion fields for camera / warp
  float animPulse = (sin(TIME * (ChaosSpeed * 2.0 + param1 * 30.0)) * 0.5 + 0.5);
  float globalSpeed = Speed * (1.0 + param1 * 0.6) * (1.0 + speed * 0.2);

  // camera ray setup
  vec2 uv_cam = (frag - 0.5 * RENDERSIZE.xy) / RENDERSIZE.y;
  uv_cam *= FOV;
  vec3 ro = vec3(0.0, 0.0, -3.0);
  vec3 rd = normalize(vec3(uv_cam * Zoom, 1.0));
  rd = cameraMatrix(CameraOrbit + rotatedUV.x * 0.1, CameraPitch + rotatedUV.y * 0.08, CameraRoll) * rd;

  // texture-based warping of camera origin (triplanar)
  vec3 warp = triplanarTexture(ro * TextureScale + vec3(rotatedUV*0.5,0.0), 1.0) - 0.5;
  vec3 roWarped = ro + warp * TextureWarp * (0.5 + 0.5 * param1);

  // raymarch loop
  vec3 color = vec3(0.0);
  float dist = 0.0;
  int steps = int(clamp(StepCount, 1.0, 60.0));
  int geom = int(clamp(GeometryType, 0.0, 6.0));
  int tpal = int(abs(floor(ColorPaletteMode))); // floor() gives float â†’ safe
int tpalAlt = int(abs(floor(palette)));


  // pre-calc some animation-driven modulations
  float chaos = ChaosIntensity * (1.0 + 0.6 * param1);
  float chspd = ChaosSpeed * (1.0 + param1*0.5);
  float sym = Symmetry + sin(TIME * 0.1) * 0.05;
  float mixAmt = ChaosMix;
  float sharp = Sharpness;
  float falloff = FalloffCurve;
  float glow = Glow;
  float br = Brightness * (1.0 + 0.4 * param1);
  float ct = Contrast * (1.0 + 0.3 * param1);
  float sat = saturation;

  for (int i = 0; i < MAX_STEPS; i++) {
    if (i >= int(clamp(StepCount, 1.0, float(MAX_STEPS)))) break;
    vec3 p = roWarped + dist * rd;

    // apply kaleidoscopic displacement to point before evaluating SDF
    // using rotatedUV and vv as low-cost displacement fields
    p += vec3(rotatedUV.xy, vv.x - vv.y) * 0.15 * (0.5 + 0.5 * shimmer);

    // transforms, fractal shape, and chaos mixing
    p = applyTransform(p, int(clamp(TransformMode, 0.0, 5.0)), chaos, sym, chspd);
    float d = sceneSDF(p, geom, chaos, mixAmt, steps);
    d = max(abs(d), 1e-3);

    // cheaper shading weight
    float fade = exp(-float(i) * 0.03 * sharp) * (1.0 - float(i) / float(MAX_STEPS));
    float focus = smoothstep(FocusNear, FocusFar, dist);

    // color sources: procedural palette, neon sin palette, texture
    vec3 palColMain = getPaletteColor(tpal, p.z * 0.25 + TIME * 0.1 + rotatedUV.x * 0.5);
    vec3 palColAlt  = getPaletteColor(tpalAlt, p.z * 0.2 - TIME * 0.05 + vv.y * 0.5);
    vec3 neon = vec3(
      0.5 + 0.5 * sin((fract(dist*0.7) * 6.2831) * param4 + TIME * param1 * 30.0 + param3),
      0.5 + 0.5 * sin((fract(dist*0.6) * 6.2831) * param4 + TIME * param1 * 30.0 + param3 + 1.0),
      0.5 + 0.5 * sin((fract(dist*0.5) * 6.2831) * param4 + TIME * param1 * 30.0 + param3 + 2.0)
    );
    vec3 texCol = triplanarTexture(p * TextureScale + vec3(rotatedUV*0.2,0.0), 1.0);

    // mix palette/texture/neon based on procedural masks
    float paletteMix = 0.5 + 0.5 * sin(dist * 0.5 + TIME * 0.2 + rotatedUV.x * 2.0);
    vec3 mixedPal = mix(palColMain, palColAlt, 0.5 + 0.5*sin(rotatedUV.y*2.0 + TIME*0.1));
    vec3 colorSample = mix(mixedPal, texCol, 0.35 + 0.65 * clamp(TextureWarp, 0.0, 1.0));
    colorSample = mix(colorSample, neon, 0.25 * (0.5 + 0.5 * param1));

    // brightness from distance/df
    float b = 0.005 / (0.01 + d * falloff);
    color += colorSample * b * fade * focus;

    dist += d;
    if (dist > BAILOUT) break;
  }

  // post processing: pulses, glow, color grading
  float pulse = 1.0 + 0.3 * (sin(TIME * ChaosSpeed * (1.0 + param1*2.0)) * 0.5 + 0.5);
  // color pulse ring
  if (colorPulse > 0.0) {
    float distUV = length(uv0);
    float ring = sin(distUV * 20.0 - TIME * 5.0 * colorPulse) * 0.25;
    pulse += ring;
  }
  color *= pulse;

  // contrast, saturation, brightness
  float lum = dot(color, vec3(0.2126, 0.7152, 0.0722));
  color = mix(vec3(lum), color, sat);
  color = mix(vec3(0.5), mix(vec3(lum), color, sat), 1.0 - (1.0/ct));
  color *= br * (1.0 + glow);

  // clamp and final gamma-ish
  color = clamp(color, 0.0, 1.0);
  color = pow(color, vec3(0.95)); // slight filmic touch

  gl_FragColor = vec4(color, 1.0);
}
